{"version":3,"file":"default-node_modules_ionic_core_dist_esm_input_utils-09c71bc7_js-node_modules_ionic_core_dist-8b8a84.js","mappings":"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","sources":["./node_modules/@ionic/core/dist/esm/input.utils-09c71bc7.js","./node_modules/@ionic/core/dist/esm/notch-controller-55b09e11.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index-a5d50daf.js';\r\nimport { r as raf } from './helpers-da915de8.js';\r\nimport { a as printIonError } from './index-9b0d46f4.js';\r\n\r\n/**\r\n * Used to update a scoped component that uses emulated slots. This fires when\r\n * content is passed into the slot or when the content inside of a slot changes.\r\n * This is not needed for components using native slots in the Shadow DOM.\r\n * @internal\r\n * @param el The host element to observe\r\n * @param slotName mutationCallback will fire when nodes on these slot(s) change\r\n * @param mutationCallback The callback to fire whenever the slotted content changes\r\n */\r\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\r\n    let hostMutationObserver;\r\n    let slottedContentMutationObserver;\r\n    if (win !== undefined && 'MutationObserver' in win) {\r\n        const slots = Array.isArray(slotName) ? slotName : [slotName];\r\n        hostMutationObserver = new MutationObserver((entries) => {\r\n            for (const entry of entries) {\r\n                for (const node of entry.addedNodes) {\r\n                    /**\r\n                     * Check to see if the added node\r\n                     *  is our slotted content.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {\r\n                        /**\r\n                         * If so, we want to watch the slotted\r\n                         * content itself for changes. This lets us\r\n                         * detect when content inside of the slot changes.\r\n                         */\r\n                        mutationCallback();\r\n                        /**\r\n                         * Adding the listener in an raf\r\n                         * waits until Stencil moves the slotted element\r\n                         * into the correct place in the event that\r\n                         * slotted content is being added.\r\n                         */\r\n                        raf(() => watchForSlotChange(node));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        hostMutationObserver.observe(el, {\r\n            childList: true,\r\n            /**\r\n             * This fixes an issue with the `ion-input` and\r\n             * `ion-textarea` not re-rendering in some cases\r\n             * when using the label slot functionality.\r\n             *\r\n             * HTML element patches in Stencil that are enabled\r\n             * by the `experimentalSlotFixes` flag in Stencil v4\r\n             * result in DOM manipulations that won't trigger\r\n             * the current mutation observer configuration and\r\n             * callback.\r\n             */\r\n            subtree: true,\r\n        });\r\n    }\r\n    /**\r\n     * Listen for changes inside of the slotted content.\r\n     * We can listen for subtree changes here to be\r\n     * informed of text within the slotted content\r\n     * changing. Doing this on the host is possible\r\n     * but it is much more expensive to do because\r\n     * it also listens for changes to the internals\r\n     * of the component.\r\n     */\r\n    const watchForSlotChange = (slottedEl) => {\r\n        var _a;\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n        slottedContentMutationObserver = new MutationObserver((entries) => {\r\n            mutationCallback();\r\n            for (const entry of entries) {\r\n                for (const node of entry.removedNodes) {\r\n                    /**\r\n                     * If the element was removed then we\r\n                     * need to destroy the MutationObserver\r\n                     * so the element can be garbage collected.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\r\n                        destroySlottedContentObserver();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Listen for changes inside of the element\r\n         * as well as anything deep in the tree.\r\n         * We listen on the parentElement so that we can\r\n         * detect when slotted element itself is removed.\r\n         */\r\n        slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\r\n    };\r\n    const destroy = () => {\r\n        if (hostMutationObserver) {\r\n            hostMutationObserver.disconnect();\r\n            hostMutationObserver = undefined;\r\n        }\r\n        destroySlottedContentObserver();\r\n    };\r\n    const destroySlottedContentObserver = () => {\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n    };\r\n    return {\r\n        destroy,\r\n    };\r\n};\r\n\r\nconst getCounterText = (value, maxLength, counterFormatter) => {\r\n    const valueLength = value == null ? 0 : value.toString().length;\r\n    const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\r\n    /**\r\n     * If developers did not pass a custom formatter,\r\n     * use the default one.\r\n     */\r\n    if (counterFormatter === undefined) {\r\n        return defaultCounterText;\r\n    }\r\n    /**\r\n     * Otherwise, try to use the custom formatter\r\n     * and fallback to the default formatter if\r\n     * there was an error.\r\n     */\r\n    try {\r\n        return counterFormatter(valueLength, maxLength);\r\n    }\r\n    catch (e) {\r\n        printIonError('Exception in provided `counterFormatter`.', e);\r\n        return defaultCounterText;\r\n    }\r\n};\r\nconst defaultCounterFormatter = (length, maxlength) => {\r\n    return `${length} / ${maxlength}`;\r\n};\r\n\r\nexport { createSlotMutationController as c, getCounterText as g };\r\n","/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index-a5d50daf.js';\r\nimport { r as raf } from './helpers-da915de8.js';\r\n\r\n/**\r\n * A utility to calculate the size of an outline notch\r\n * width relative to the content passed. This is used in\r\n * components such as `ion-select` with `fill=\"outline\"`\r\n * where we need to pass slotted HTML content. This is not\r\n * needed when rendering plaintext content because we can\r\n * render the plaintext again hidden with `opacity: 0` inside\r\n * of the notch. As a result we can rely on the intrinsic size\r\n * of the element to correctly compute the notch width. We\r\n * cannot do this with slotted content because we cannot project\r\n * it into 2 places at once.\r\n *\r\n * @internal\r\n * @param el: The host element\r\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\r\n * @param getLabelSlot: A function that returns a reference to the slotted content.\r\n */\r\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\r\n    let notchVisibilityIO;\r\n    const needsExplicitNotchWidth = () => {\r\n        const notchSpacerEl = getNotchSpacerEl();\r\n        if (\r\n        /**\r\n         * If the notch is not being used\r\n         * then we do not need to set the notch width.\r\n         */\r\n        notchSpacerEl === undefined ||\r\n            /**\r\n             * If either the label property is being\r\n             * used or the label slot is not defined,\r\n             * then we do not need to estimate the notch width.\r\n             */\r\n            el.label !== undefined ||\r\n            getLabelSlot() === null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    const calculateNotchWidth = () => {\r\n        if (needsExplicitNotchWidth()) {\r\n            /**\r\n             * Run this the frame after\r\n             * the browser has re-painted the host element.\r\n             * Otherwise, the label element may have a width\r\n             * of 0 and the IntersectionObserver will be used.\r\n             */\r\n            raf(() => {\r\n                setNotchWidth();\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * When using a label prop we can render\r\n     * the label value inside of the notch and\r\n     * let the browser calculate the size of the notch.\r\n     * However, we cannot render the label slot in multiple\r\n     * places so we need to manually calculate the notch dimension\r\n     * based on the size of the slotted content.\r\n     *\r\n     * This function should only be used to set the notch width\r\n     * on slotted label content. The notch width for label prop\r\n     * content is automatically calculated based on the\r\n     * intrinsic size of the label text.\r\n     */\r\n    const setNotchWidth = () => {\r\n        const notchSpacerEl = getNotchSpacerEl();\r\n        if (notchSpacerEl === undefined) {\r\n            return;\r\n        }\r\n        if (!needsExplicitNotchWidth()) {\r\n            notchSpacerEl.style.removeProperty('width');\r\n            return;\r\n        }\r\n        const width = getLabelSlot().scrollWidth;\r\n        if (\r\n        /**\r\n         * If the computed width of the label is 0\r\n         * and notchSpacerEl's offsetParent is null\r\n         * then that means the element is hidden.\r\n         * As a result, we need to wait for the element\r\n         * to become visible before setting the notch width.\r\n         *\r\n         * We do not check el.offsetParent because\r\n         * that can be null if the host element has\r\n         * position: fixed applied to it.\r\n         * notchSpacerEl does not have position: fixed.\r\n         */\r\n        width === 0 &&\r\n            notchSpacerEl.offsetParent === null &&\r\n            win !== undefined &&\r\n            'IntersectionObserver' in win) {\r\n            /**\r\n             * If there is an IO already attached\r\n             * then that will update the notch\r\n             * once the element becomes visible.\r\n             * As a result, there is no need to create\r\n             * another one.\r\n             */\r\n            if (notchVisibilityIO !== undefined) {\r\n                return;\r\n            }\r\n            const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\r\n                /**\r\n                 * If the element is visible then we\r\n                 * can try setting the notch width again.\r\n                 */\r\n                if (ev[0].intersectionRatio === 1) {\r\n                    setNotchWidth();\r\n                    io.disconnect();\r\n                    notchVisibilityIO = undefined;\r\n                }\r\n            }, \r\n            /**\r\n             * Set the root to be the host element\r\n             * This causes the IO callback\r\n             * to be fired in WebKit as soon as the element\r\n             * is visible. If we used the default root value\r\n             * then WebKit would only fire the IO callback\r\n             * after any animations (such as a modal transition)\r\n             * finished, and there would potentially be a flicker.\r\n             */\r\n            { threshold: 0.01, root: el }));\r\n            io.observe(notchSpacerEl);\r\n            return;\r\n        }\r\n        /**\r\n         * If the element is visible then we can set the notch width.\r\n         * The notch is only visible when the label is scaled,\r\n         * which is why we multiply the width by 0.75 as this is\r\n         * the same amount the label element is scaled by in the host CSS.\r\n         * (See $form-control-label-stacked-scale in ionic.globals.scss).\r\n         */\r\n        notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\r\n    };\r\n    const destroy = () => {\r\n        if (notchVisibilityIO) {\r\n            notchVisibilityIO.disconnect();\r\n            notchVisibilityIO = undefined;\r\n        }\r\n    };\r\n    return {\r\n        calculateNotchWidth,\r\n        destroy,\r\n    };\r\n};\r\n\r\nexport { createNotchController as c };\r\n"],"names":["w","win","r","raf","a","printIonError","createSlotMutationController","el","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","undefined","slots","Array","isArray","MutationObserver","entries","entry","node","addedNodes","nodeType","Node","ELEMENT_NODE","includes","slot","watchForSlotChange","observe","childList","subtree","slottedEl","_a","disconnect","removedNodes","destroySlottedContentObserver","parentElement","destroy","getCounterText","value","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","e","maxlength","c","g","createNotchController","getNotchSpacerEl","getLabelSlot","notchVisibilityIO","needsExplicitNotchWidth","notchSpacerEl","label","calculateNotchWidth","setNotchWidth","style","removeProperty","width","scrollWidth","offsetParent","io","IntersectionObserver","ev","intersectionRatio","threshold","root","setProperty"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1]}